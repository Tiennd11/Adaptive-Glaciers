# -*- coding: utf-8 -*-
"""3_adaptive_3D.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YQgJ-0RkRVlWMrVZwQtr0MzQuA08Mixx

# Stress state within a prestine ground glacier.

In this code, we'll gain insight into the behaviour of  pristine glaciers that are land terminating and ocean terminating. Mimicking the conditions relevant to grounded glaciers, a free slip condition is applied to the bottom surface, restraining the displacement in the vertical direction. The normal component of the displacement field at the far left edge is restrained to prevent rigid body motion in the horizontal direction. The top surface, representing the atmosphereâ€“ice interface, is defined as a free boundary.
"""

# Commented out IPython magic to ensure Python compatibility.
## Step 1: Preprocessing
# - Define units: N, m
# - Prepare the design basis report
## Step 2: Importing Necessary Libraries
from dolfin import *
import ufl
from helpers import *
from problem_definition import *
from matplotlib import pyplot as plt
import time

# %matplotlib inline
## Step 3: Loading the Mesh
mesh = Mesh()
with XDMFFile("mesh/Mesh_5_70.xdmf") as infile:
    infile.read(mesh)
print("H_min before AMR : %f", mesh.hmin())

## Step 4: Preparing output file
xdmf = XDMFFile("output/solution-Mesh_5_70_S-15-thres-1.5-hmin-14.xdmf")
xdmf.parameters["functions_share_mesh"] = True
xdmf.parameters["rewrite_function_mesh"] = True
xdmf.parameters["flush_output"] = True

hmin_target = 14

lx,ly,lz=750,500,125
L, B, H = lx, ly, lz







def problem(mesh, time_total=100, ms_iterations=1,p_adaptive=None, cdf_adaptive = None):
    ## Step 5: Preparing the sets
    # lx,ly,lz=750,500,125
    front = CompiledSubDomain("near(x[0], 0)")
    back = CompiledSubDomain("near(x[0], L)",L=L)
    left = CompiledSubDomain("near(x[1], 0)")
    right_csd = CompiledSubDomain("near(x[1], B)", B=B)
    bottom = CompiledSubDomain("near(x[2], 0)")
    top = CompiledSubDomain("near(x[2], H)", H=H)



    ## Step 6: Defining  spaces
    V1 = VectorFunctionSpace(mesh, "CG", 1)
    F1 = FunctionSpace(mesh, "CG", 1)

    FDG0 = FunctionSpace(mesh, "DG", 0)
    TDG0 = TensorFunctionSpace(mesh, "DG", 0)
    ## Step 7: Define functions
    u, v = TrialFunction(V1), TestFunction(V1)
    unew, uold = Function(V1, name="disp"), Function(V1, name="disp")
    stress_xx, cdf = Function(F1, name="sigma_xx"), Function(F1, name="cdf")
    p, q = TrialFunction(F1), TestFunction(F1)

    pnew, pold = Function(F1, name="damage"), Function(F1, name="damage")

    # if p_adaptive is not None:
    #     pold.assign(project(p_adaptive,F1))

    if p_adaptive is not None:
        pold.assign(project(p_adaptive, F1))
        pnew.assign(project(p_adaptive, F1))
    if cdf_adaptive is not None:
        cdf.assign(project(cdf_adaptive, FDG0))


    ## Step 8: Material Model
    # N, m, Pa
    grav = 9.81
    g = grav
    rho_sea = 1020
    E0_ice = 9500e6
    nu_ice = 0.35
    rho_i_ice = 917
    sigma_c_ice = 0.1185e6
    l = 10
    ice = MaterialModel(E0_ice, nu_ice, rho_i_ice, sigma_c_ice, 1)

    ## Step 9: Define supports
    bottom_roller = DirichletBC(V1.sub(2), Constant(0), bottom)
    left_roller = DirichletBC(V1.sub(1), Constant(0), left)
    front_roller = DirichletBC(V1.sub(0), Constant(0), front)
    back_roller = DirichletBC(V1.sub(0), Constant(0), back)

    # def Psii(p):
    #     if p>0.6:
    #         pis = 0
    #     else:
    #         pis = 1
    
#     z_co_ord = Function(D1)
#     z_co_ord.interpolate(Expression("x[2]", degree=1))

    boundaries = MeshFunction("size_t", mesh, mesh.topology().dim() - 1)
    left.mark(boundaries, 1)
    right_csd.mark(boundaries, 2)
    bottom.mark(boundaries, 3)
    top.mark(boundaries, 4)
    ds = Measure("ds", subdomain_data=boundaries)
    bc_u = [bottom_roller, left_roller,front_roller,back_roller]

    ## Step 10: Define Loads
    hw = 0.48*lz
    t = Expression((0, "(h - x[2] >= 0 ?-rho_H2O * grav*(h - x[2]) : 0)", 0), h=hw, rho_H2O=rho_sea, grav= grav, degree=1)
#     t = Expression(("-(rho_sea*(125/2 -x[1]))", 0), rho_sea=rho_sea*g, degree=1)
    # t = Constant((0, 0))
    f = Constant((0, 0, -ice.rho * g))

    ## Step 11: Define the problem
    a_disp = inner(degradation(pold) * ice.stress(u), ice.strain(v)) * dx
    L_disp = (1-pold)*dot(f, v) * dx + dot(t, v) * ds(2)
    a_phase = ((1 + cdf) * inner(p, q) + l**2 * inner(grad(p), grad(q))) * dx
    L_phase = inner(cdf, q) * dx

    ## Step 12: Solve
    disp_problem = LinearVariationalProblem(a_disp, L_disp, unew, bc_u)
    phase_problem = LinearVariationalProblem(a_phase, L_phase, pnew)
    problem = FractureProblem(disp_problem, phase_problem, ice, cdf)
    solver = FractureSolver(problem)
    prm = solver.parameters
    prm["time_start"] = 0.0
    prm["time_total"] = time_total
    prm["delta_t"] = 1.0
    prm["multi_staggered"]["tolerance"] = 1e-5
    prm["multi_staggered"]["maximum_iterations"] = ms_iterations
    solver.solve()

    return pnew, cdf









def get_markers(phi, mesh, target_hmin):
    adaptivity_converged = False

    marker = MeshFunction("bool", mesh, mesh.topology().dim())
    marker.set_all(False)

    DG = FunctionSpace(mesh, "DG", 0)
    phi.assign(project(phi,DG))
#     marker.array()[phi.vector()[:] > 0.01] = True
    marker.array()[phi.vector()[:] > 0.01] = True

    # ---------------------------------------------------------------------------------
    # Scheme S4    -----------------------------------------------------
    # ---------------------------------------------------------------------------------
    cell_dia = Circumradius(mesh)
    dia_vector = project(cell_dia, DG, solver_type="cg",
        preconditioner_type="hypre_euclid").vector()[:]
    marker.array()[dia_vector < target_hmin] = False
    # ---------------------------------------------------------------------------------
    # ---------------------------------------------------------------------------------
    DG = None
    del DG

    adaptivity_converged = np.all(np.invert(marker.array()))
    return marker, adaptivity_converged









adaptivity_converged = False
while not adaptivity_converged:
    pold,cdf_old = problem(mesh, 0.0, 1)
    marker, adaptivity_converged = get_markers(pold, mesh, target_hmin=hmin_target)
    # print(adaptivity_converged)
    mesh = refine(mesh, marker)
    # plot(mesh)


xdmf.write(pold,0)








cpp_code = """
#include <pybind11/pybind11.h>
#include <dolfin/adaptivity/adapt.h>
#include <dolfin/function/Function.h>
#include <dolfin/mesh/Mesh.h>
namespace py = pybind11;
PYBIND11_MODULE(SIGNATURE, m)
{
m.def("adapt", [](const dolfin::Function &function,
          std::shared_ptr<const dolfin::Mesh> adapted_mesh,
                  bool interpolate){
             return dolfin::adapt(function, adapted_mesh, interpolate);});
}
"""
m = compile_cpp_code(cpp_code)


def adaptFunction(f, mesh, interp=True):
    return m.adapt(f, mesh, interp)

def transfer(_p, mesh):
    _p = Function(adaptFunction(_p._cpp_object, mesh))
    return _p







p_adaptive_n = pold
cdf_adaptive_n = cdf_old

for i in range(500):
    adaptivity_converged = False
    while not adaptivity_converged:
        p_adaptive_n_1, cdf_adaptive_n_1 = problem(mesh, 0.0, 1, p_adaptive_n, cdf_adaptive_n)
        marker, adaptivity_converged = get_markers(
            p_adaptive_n_1, mesh, target_hmin=hmin_target)
        print(adaptivity_converged)
        mesh = refine(mesh, marker)
        p_adaptive_n = transfer(p_adaptive_n, mesh)
        cdf_adaptive_n = transfer(cdf_adaptive_n, mesh)
    p_adaptive_n.assign(p_adaptive_n_1)
    cdf_adaptive_n.assign(cdf_adaptive_n_1)
    p_adaptive_n.rename("damage", "damage")
    xdmf.write(p_adaptive_n, i+1)


# mesh.hmin(), mesh.num_cells()
    # print("H_min finall AMR : %f, time: %", mesh.hmin(), time.time() - start)



# plt.figure(figsize=(18, 6))
# c = plot(p_adaptive_n)
# plt.colorbar(c)  # Adds the colorbar
# plt.show()

